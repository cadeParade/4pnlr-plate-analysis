source("corr2.R")
corr2("specdata", 800)
source("corr2.R")
corr2("specdata", 800)
cr<-corr2("specdata", 150)
head(cr)
summary(cr)
cr<-corr2("specdata", 400)
source("corr2.R")
cr<-corr2("specdata", 400)
source(corr2.R)
source("corr2.R")
cr<-corr2("specdata", 400)
source("corr2.R")
cr<-corr2("specdata", 400)
head(cr)
source("corr2.R")
cr<-corr2("specdata", 400)
head(cr)
source("corr2.R")
cr<-corr2("specdata", 400)
head(cr)
summary(cr)
cr<-corr2("specdata", 5000)
head(cr)
summary(cr)
length(cr)
cr<-corr2("specdata")
summary(cr)
length(cr)
source("http://spark-public.s3.amazonaws.com/compdata/scripts/corr-test.R")#
corr.testscript()
source("corr.R")
source("http://spark-public.s3.amazonaws.com/compdata/scripts/corr-test.R")#
corr.testscript()
cr
length(cr)
sample(length(cr),5)
cr[sample(length(cr),5)]
round(cr[sample(length(cr),5)],4)
out <- round(cr[sample(length(cr),5)],4)
outputfiles
outputfiles <- sprintf("corr-testoutput%d.txt", 1:3)
outputfiles[1]
writeLines(as.character(out), outputfiles[1])
source("testing.R")
testing()
local()
corr.testscript()
source("testing.R")
corr.testscript()
source("testing.R")
corr.testscript()
source("testing.R")
corr.testscript()
source("corr.R")
source("testing.R")
source("http://spark-public.s3.amazonaws.com/compdata/scripts/corr-test.R")#
corr.testscript()
source("testing.R")
help(source)
help(sort)
source("corr.R")
corr("specdata", 999)
corr("specdata", 1000)
cr <- corr("specdata", 2000)#
                n <- length(cr)#
                cr <- corr("specdata", 1000)#
                cr <- sort(cr)#
                writeLines(as.character(c(n, round(cr, 4))))
source("http://spark-public.s3.amazonaws.com/compdata/scripts/corr-test.R")#
corr.testscript()
source("corr.R")
source("http://spark-public.s3.amazonaws.com/compdata/scripts/corr-test.R")#
corr.testscript()
help(set)
help(seed)
help(set.seed)
set.seed(197)
a<set.seed(198)
a<-set.seed(192)
a
debug(ls)
ls()
ls(3)
debug(ls)
ls()
help(debug)
continue
go
next
stop
break
stop()
1
2
0
ls
outcome<-read.csv("ProgAssignment2-data/outcome-of-care-measures.csv")
head(outcome)
outcome[,11] <- as.numeric(outcome[,11])
hist(outcome[,11])
outcome[, 11] <- as.numeric(outcome[, 11])
hist(outcome[, 11])
outcome<-read.csv("ProgAssignment2-data/outcome-of-care-measures.csv", colClasses = "character")
outcome[, 11] <- as.numeric(outcome[, 11])
hist(outcome[, 11])
title("Heart Attack 30-day Death Rate")
list("hist")
list(hist)
list(plot)
xlab("30 day Death Rate")
hist(outcome[, 11], xlab="30-day Death Rate", title="Heart Attack 30-day Death Rate")
hist(outcome[, 11], xlab="30-day Death Rate")
title("30-Day Heart Attack Death Rate")
hist(outcome[, 11], xlab="30-day Death Rate", main="30-Day Heart Attack Death Rate")
hist(outcome[, 11], xlab="30-day Death Rate", main="30-Day Heart Attack Death Rate", sub="sub")
help(hist)
names(outcome)
source("Rhw2.R")
head(outcome[,11])
head(outcome)
source("Rhw2.R")
help(colClass)
??colClass
help(read.csv)
source("Rhw2.R")
type.convert(14.3)
type.convert(as.string(14.3))
type.convert("14.3")
source("Rhw2.R")
help(range)
range(outcome[,11])
range(as.numeric(outcome[,11])
source("Rhw2.R")
help(plot)
help(hist)
source("Rhw2.R")
help(abline)
hist(outcome[,11])
source("Rhw2.R")
outcome<-read.csv("ProgAssignment2-data/outcome-of-care-measures.csv", colClasses = "character")
hist(outcome[,11])
outcome[,11]<-as.numeric(outcome[,11])
hist(outcome[,11])
abline(v="mean(outcome[,11])")
mean(oucome[,11])
myMean<-mean(outcome[,11])
myMean
onona<-na.omit(outcome[,11])
mean(onona)
hist(onona)
abline(v=mean(onona))
source("Rhw2.R")
help(colClasses)
??colClasses
help(read.csv)
help(plotmath)
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= .25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= 5.25)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= 0)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
How to combine "math" and numeric variables :#
plot(1:10, type="n", xlab="", ylab="", main = "plot math & numbers")#
theta <- 1.23 ; mtext(bquote(hat(theta) == .(theta)), line= -4)#
for(i in 2:9)#
    text(i,i+1, substitute(list(xi,eta) == group("(",list(x,y),")"),#
                           list(x=i, y=i+1)))
help(mtext)
plot(1:10, (-4:5)^2, main="Parabola Points", xlab="xlab")#
mtext("10 of them")#
for(s in 1:4)#
    mtext(paste("mtext(..., line= -1, {side, col, font} = ",s,#
          ", cex = ", (1+s)/2, ")"), line = -1,#
          side=s, col=s, font=s, cex= (1+s)/2)#
mtext("mtext(..., line= -2)", line = -2)#
mtext("mtext(..., line= -2, adj = 0)", line = -2, adj =0)
plot(1:10, exp(1:10), log='y', main="log='y'", xlab="xlab")#
for(s in 1:4) mtext(paste("mtext(...,side=",s,")"), side=s)
source("Rhw2.R")
help(plotmath)
demo(plotmath)
x<-3.14
bar(x)
plotmath(bar(x))
require(graphics)#
#
x <- seq(-4, 4, len = 101)#
y <- cbind(sin(x), cos(x))#
matplot(x, y, type = "l", xaxt = "n",#
        main = expression(paste(plain(sin) * phi, "  and  ",#
                                plain(cos) * phi)),#
        ylab = expression("sin" * phi, "cos" * phi), # only 1st is taken#
        xlab = expression(paste("Phase Angle ", phi)),#
        col.main = "blue")#
axis(1, at = c(-pi, -pi/2, 0, pi/2, pi),#
     labels = expression(-pi, -pi/2, 0, pi/2, pi))
help(expression)
help(paste)
help(plain)
source("Rhw2.R")
expression(paste(integral(),"f(",tau,") d",tau,sep="")))
expression(paste(integral(),"f(",tau,") d",tau,sep=""))
library(lattice)
library(nlme)
xyplot(distance~age|Subject,data=Orthodont)
xyplot(distance~age|Subject,data=Orthodont, type="b")
source("Rhw2.R")
help(substitute)
source("Rhw2.R")
pal <- colorRampPalette(c("red", "yellow", "blue"))
x <- rnorm(100)
plot(x, col=pal(100))
plot(x, col=pal(10))
plot(x, col=pal(1000))
plot(x, col=pal(200))
plot(x, col=pal(50))
plot(x, col=pal(10))
plot(x, col=pal(11))
plot(x, col=pal(12))
plot(x, col=pal(13))
plot(x, col=pal(20))
plot(x, col=pal(30))
plot(x, col=pal(50))
plot(x, col=pal(10))
> ####                           ########
> ####                           ########
> #### THINGS YOU NEED TO CHANGE ########
> ####                           ########
> ####                           ########
> #######################################
> #
> #
> ##### CHANGE THIS 				######
> ##### IF YOU USE 				######
> ##### DIFFERENT CONCENTRATIONS	######
> concVec <- c("10e-10","10e-9","10e-8","10e-7","10e-6","10e-5")#
> #
> ########### CHANGE THIS FILE LOCATION 	################
> ########### TO WHERE YOUR EXPERIMENTAL  ################
> ########### EXCEL FILES ARE. 			################
> ########### for windows,     			################
> ########### the "/" is "\"  			################
> ## note that the perl scripts that gdata uses do not cope well#
> ## with tilde expansion on unix machines. So use the full path.#
> #
> directory <- "/Users/andrew/Desktop/experiment"#
> #
> #
> #######################################
> ####                           ########
> ####                           ########
> ####          FUNCTIONS        ########
> ###(setup for "actions" section)#######
> ####                           ########
> #######################################
> #
> ####### Converts excel sheets to csv files  ##############
> convertExcel <- function(dir){#
+ 	####### lifted directly from here: #
+ 	####### http://stackoverflow.com/questions/#
+ 	####### 8188415/save-excel-spreadsheet-as-csv-with-r	#
+ #
+ 	 #
+ 	#creates vector of xls file names in directory. #
+ 	excelFileList <- list.files(dir, full.names=T, pattern="xls$")#
+ 	#for each xls file in directory, creates csv out of Plate_Page1#
+ 	for(i in seq_along(excelFileList)){#
+ 		#assigns file i to excelFile var#
+ 		excelFile <- excelFileList[i]#
+ 		#gets sheet 2 from excelFile	#
+ 		plateSheet <- read.xls(excelFile, sheet=2)#
+ 		#writes csv of sheet 2 named original filename + csv#
+ 		write.csv(plateSheet, file=paste(excelFileList[i],"csv", sep="."))#
+ 	#
+ 		#Use this if you want all sheets in excel file converted to csv#
+ 		#numSheets<-sheetCount(excelFile, verbose=TRUE)#
+ 		#for ( i in 1:numSheets) {#
+ 	 	#	mySheet <- read.xls(excelFile, sheet=i)#
+ 	 	#	write.csv(mySheet, file=paste(i, "csv", sep="."), row.names=FALSE)#
+ 		#}	#
+ 	}#
+ }#
> #
> #gets data out of all csv files and extracts correct area of spreadsheet#
> readingData <- function(dir){#
+ 	#
+ 	#creates vector of csv files in dir#
+ 	csvFileList <- list.files(dir,full.names=T, pattern="csv$")#
+ 	allPlates <- list()#
+ 	for(i in seq_along(csvFileList)){#
+ 		#reads in csv file#
+ 		plate <-read.csv(csvFileList[i], header=F, colClasses = "character")#
+ 		#converts to dataframe#
+ 		plate <- as.data.frame(plate)#
+ 		#gets only the 96 well plate area into the plate#
+ 		plate <- plate[7:14,2:13]#
+ 		#adds 96 well plate to list of all plates in directory#
+ 		#I don't know why double brackets does this#
+ 		allPlates[[i]] <-plate#
+ 	}#
+ 	return(allPlates)#
+ }#
> #
> #
> #Finds minimum for plate and subtracts from whole plate#
> minimize <- function(rawPlate){#
+ 	#
+ 	#gets data frame out of list rawPlate	#
+ 	numericPlate <- as.data.frame(rawPlate[1])#
+ 	#converts each column to numeric#
+ 	numericPlate <- as.data.frame(#
+ 		sapply(numericPlate,FUN=function(col) as.numeric(col)))#
+ 	#finds minimum of entire plate#
+ 	plateMin <- min(numericPlate)#
+ 	#subtracts plateMin from each item in table#
+ 	subtracted <- as.data.frame(sapply(numericPlate,FUN=function(col) col-plateMin))#
+ 	return(subtracted)#
+ }#
> #
> #
> #normalizes plates(scales each value 1-100%)#
> normalize <- function(exp){#
+ 	#
+ 	#takes average of column A for individual experiment#
+ 	colaavg <- mean(exp[,1])#
+ 	#normalizes experiment to column A average#
+ 	exp <- as.data.frame(sapply(exp, #
+ 		FUN=function(cell) (cell/colaavg)*100))	 	#
+ }#
> #
> #
> #Turns wide formatted plate into long format for regression function#
> reformat <- function(normalizedExp, concs){#
+ 	#
+ 	# Reshapes exp1 to be all in column format. This is required for the drm function.#
+ 	normalizedLong <- reshape(normalizedExp, varying=list(colnames(normalizedExp)), 		direction="long")#
+ 	#renames column names. Using the reshape function puts names we don't want. #
+ 	colnames(normalizedLong) <- c("conc","abs","rep")#
+ 	#replace "1"-"6" in conc column with correct corresponding concentration value#
+ 	normalizedLong$conc <- sapply(normalizedLong$conc, #
+ 		function(colindex) concs[colindex])#
+ 	#adds column "curve" to table (this is optional, for drm function)#
+ 	normalizedLong$curve <- 1#
+ 	#sorts table by rep (unnecessary, but you can if you want)#
+ 	#normalizedLong <- exp1Long[order(exp1Long[,3]),]#
+ 	#converts conc and abs column to numeric so they can be graphed#
+ 	normalizedLong$conc <- as.numeric(normalizedLong$conc)#
+ 	normalizedLong$abs <- as.numeric(normalizedLong$abs)#
+ #
+ 	return(normalizedLong)	#
+ }#
> #
> #
> findLine <- function(normalizedData){#
+ 	#######THIS IS WHAT FINDS THE REGRESSION LINE#############
+ 	#graphs abs vs conc, curve 1, data is from table "normalizedData, #
+ 	#uses function "LL.4() to find regression line)#
+ 	#documentation here: http://cran.r-project.org/web/packages/drc/drc.pdf#
+ 	#the curve property is for when you want to put more than one #
+ 	#curve on one graph. To do this, put all the data in one dataframe with #
+ 	#exp1long format and then change the curve column to express which curve #
+ 	#you want each point to be on.#
+ 	#
+ 	pnl <- drm(abs~conc, curve, data = normalizedData, fct = LL.4())#
+ #
+ 	#to output all coefficients in R console, uncomment line below#
+ 	#print(pnl)#
+ 	return(pnl)#
+ }#
> 	#
> #
> #gets "E" intercept into seperate variable#
> findIntercept<- function(regression){#
+ #
+ 	#######gets numeric value of coefficients in table#
+ 	#coef function puts calculated coefficients into vector#
+ 	coefs <- coef(regression)#
+ 	#assigns "E" to intercept#
+ 	intercept <- coefs[4]#
+ 	#
+ 	return(intercept)#
+ }#
> #
> #
> plotting <- function(regression, intercept,expName,plateQuadrant,errorInfo){#
+ 	#puts together original file name + A-D depending on plate quadrant#
+ 	filename <- paste(expName,plateQuadrant,sep="-")#
+ 	#prints plot to pdf file#
+ 	#   if you want to test the program by printing to screen only,#
+ 	#   comment out the pdf() line below and the "dev.off()" line #
+ 	#   at the end of the function#
+ 	pdf(paste(filename,"pdf",sep="."))#
+ 	#
+ 	#graphs the calculated regression curve#
+ 	plot(regression, #
+ 		main=filename, 					#title of graph#
+ 		ylab="% Activity", 				#title of y axis#
+ 		xlab="log[inhibitor] (M)", 		#title of x axis#
+ 		col="red4", 					#color of line#
+ 		ylim=range(0,100),				#range of y axis#
+ 		xlim=range(10e-10,10e-5), 		#range of x axis#
+ 		axes=F )						#doesn't draw axes#
+ 	#draws custom x axis#
+ 	axis(1, 							#places x axis		#
+ 		at=as.numeric(concVec),			#where ticks go #
+ 		labels=concVec, 				#text for labels#
+ 		las=1,							#sets tick labels horizontal#
+ 		cex.axis=0.8					#shrink tick labels to 80%#
+ 		)#
+ 	#draws custom y axis#
+ 	axis(2, 							#places y axis#
+ 		at=c(0,20,40,60,80,100), 		#where ticks go#
+ 		labels=c(0,20,40,60,80,100), 	#tick labels#
+ 		las=1,							#sets tick labels horizontal#
+ 		)#
+ 	#graphs EC50 point#
+ 	points( intercept,					# x coord of point#
+ 			50, 						# y coord of point#
+ 			pch=8, 						# assigns star symbol#
+ 			col="blue")					# assigns blue color#
+ 	#
+ 	#rounds intercept to 4 digits#
+ 	roundIntercept <- format(intercept, digits=4)#
+ 	#
+ 	#displays text at coordinates (intercept, 50)#
+ 	#the complicated code is to get the subscript "50"#
+ 	text(intercept, 50,					#coordinates of text #
+ 		substitute(EC[50]~"="~inter, 	#lays out which text to display#
+ 		list(inter=roundIntercept)), 	#plugs in number to intercept#
+ 		adj=c(1.1,0.5), 				#moves text a little down and to the left#
+ 		cex=0.8)						#makes size of text 20% smaller#
+ 	#
+ #
+ 	#### ERROR BARS #####
+ 	#converts error info into useable data#
+ 	concVec<- as.numeric(concVec)#
+ 	avgs <- errorInfo[,1]#
+ 	stdevs <- errorInfo[,2]#
+ 	#
+ 	#cycles through each point on plot through vector avgs#
+ 	for(i in 1:length(avgs)){#
+ 		#prints error bar above point#
+ 		arrows( concVec[i], 			# start x coord#
+ 				avgs[i], 				# start y coord#
+ 				concVec[i], 			# end x coord#
+ 				avgs[i]+stdevs[i], 		# end y coord#
+ 				angle=90, 				# angle of end cap#
+ 				length=0.03)			# length of end cap#
+ 		#prints error bar below point#
+ 		arrows( concVec[i], 			# start x coord#
+ 				avgs[i], 				# start y coord#
+ 				concVec[i], 			# end x coord#
+ 				avgs[i]-stdevs[i], 		# end y coord#
+ 				angle=90, 				# angle of end cap#
+ 				length=0.03)			# length of end cap#
+ #
+ 		#
+ 	}#
+ 	#
+ 	#turns off graphics device#
+ 	dev.off()#
+ }#
> #
> #makes dataframe for error bars#
> findAvgsAndStdev<- function(exp){#
+ 	avgsAndStdevs <- data.frame(avgs=sapply(exp,mean), stdevs=sapply(exp,sd))#
+ 	return(avgsAndStdevs)#
+ }#
> #
> #
> #combines all functions#
> doAll <- function(exp,expName,plateQuadrant,i){#
+ 	normalizedExp <- normalize(exp)#
+ 	expLong <- reformat(normalizedExp,concVec)#
+ 	line <- findLine(expLong)#
+ 	intercept<-findIntercept(line)#
+ 	errorInfo<- findAvgsAndStdev(normalizedExp)#
+ 	graph <- plotting(line,intercept,expName,plateQuadrant,errorInfo)#
+ }#
> #
> #
> #
> ###### ACTIONS ########
> ###### ACTIONS ########
> ###### ACTIONS ########
> ###### ACTIONS ########
> #
> #converts excel files to csv files#
> convertExcel(directory)#
> #
> #puts correct table from all csv files in directory #
> #into one vector called allPlates#
> allPlates <- readingData(directory)#
> #
> #
> #
> #cycles through each item (one per csv file) in vector allPlates #
> #for each item the table is split into four, regression analysis#
> #is done and a graph with regression line and EC50 is saved#
> for (i in seq_along(allPlates)){#
+ 	#
+ 	#
+ 	#Retreives original file names for generating new file names#
+ 	csvFileList <- list.files(directory,full.names=F, pattern="csv$")#
+ 	#assigns current file name#
+ 	currentPlateName<- csvFileList[i]#
+ 	#takes ".csv" off of ending#
+ 	currentPlateName<- sub(".xls.csv","",currentPlateName)#
+ 	#
+ 	currentPlate <- allPlates[i]#
+ 	#
+ 	#
+ 	#finds minimum of whole plate and subtracts from each cell#
+ 	minimizedPlate <- minimize(currentPlate)#
+ 	 #
+ 	#
+ #
+ 	#Divide whole plate into seperate experiments#
+ 	exp1 <- minimizedPlate[1:4,1:6]#
+ 	exp2 <- minimizedPlate[5:8,1:6]#
+ 	exp3 <- minimizedPlate[1:4,7:12]#
+ 	exp4 <- minimizedPlate[5:8,7:12]#
+ #
+ 	#sets up display page so 4 histograms show in a 2x2 grid#
+ 	#par(mfrow=c(2,2))#
+ 	#
+ 	doAll(exp1,currentPlateName,"A")#
+ 	doAll(exp2,currentPlateName,"B")#
+ 	doAll(exp3,currentPlateName,"C")#
+ 	doAll(exp4,currentPlateName,"D")#
+ 	#
+ }#
>
help(pdf)
search()
source("Andrew_Program.R")
pdf("mypdf")
pdf(paste("mypdf","pdf",sep="."))
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
help(pdf)
PDF Format  #
# The 'pdf' device allows for PDF output.  #
#  #
# Height and Width: Dimensions of the image in inches  #
# Onefile: If true, it plots multiple figures on a page. If false,  #
#      each figure gets its own numbered page.  #
# Family: The font family used to render text. You can use most fonts  #
#     available to your computer.  #
# Paper: The type of paper determines the pdf size.  #
# Pointsize: Font size.  #
pdf(file='PDF Output.pdf', height=6, width=6, onefile=TRUE, family='Helvetica', paper='letter', pointsize=12)  #
# Plot your graph  #
plot(1:10,1:10)  #
# Write the file  #
dev.off()
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
source("Andrew_Program.R")
library(ggplot2)#
r <- ggplot(data = diamonds, aes(x = carat, y = price, color = cut, group = cut))#
r + geom_smooth() #(left)#
r + geom_smooth(size = 2)  #(right)
help(demo)
source("Andrew_Program.R")
source("Andrew_Program.R")
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
.pardefault<-par()
.pardefault
source('~/Desktop/Andrew/Andrew_Program.R', chdir = TRUE)
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
source("Andrew_program.R")
